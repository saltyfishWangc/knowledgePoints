拷贝也是创建对象的一种方式，下面就对象的创建方式作下总结：
创建对象有5种方式：
① 通过new关键字
这是最常用的一种方式，通过new关键字调用类的有参或无参构造方法来创建对象。如：Object obj = new Object();
② 通过Class类的newInstance()方法
这种默认是调用类的无参构造方法创建对象。如：Person p = (Person) Class.forName("com.wangc.knowledgepoints.Person").newInstance();
③ 通过Contructor类的newInstance方法
这和上面的情况类似，都是通过反射。只是这种是指定构造器来生成，而不是默认的。如：
Person p = (Person) Person.class.getConstructors()[0].newInstance();
④ 反序列化
序列化是把堆内存种的Java对象数据，通过某种方式把对象存储到磁盘文件种或者传递给其他网络节点（在网络上传输）。反序列化则是把磁盘文件或网络中的对象数据，恢复成Java对象模型的过程。
关于序列化/反序列化的知识查看序列化包
⑤ 利用clone方法
clone是Object类中的一个方法，通过对象A.clone()方法会创建一个内容和对象A一模一样的对象B，clone顾名思义就是创建一个一模一样的对象出来。
Person B = (Person) A.clone();

拷贝是利用Object类的clone()方法来实现的。
Object.class类中clone方法源码为：
protected native Object clone() throws CloneNotSupportedException;
这是用native关键字修饰的方法，native修饰的方法就是告诉操作系统，这个方法开发不实现，让操作系统去实现。

注意：所有要实现拷贝的类都必须得实现Cloneable接口，这个接口是个空接口相当于是个标识作用，目的是让虚拟机知道这个类可以进行拷贝

拷贝又分浅拷贝和深拷贝两种实现方式：
① 浅拷贝是默认的拷贝方式
② 深拷贝是指类中包含引用类型的成员变量

所以归根结底出现深拷贝的原因是基于基本类型、引用类型。下面针对基本类型、引用类型说明下，也就解释了为什么要实现深拷贝：

Java种基本类型和引用类型的区别：
在Java种数据类型可以分为两大类：基本类型和引用类型
基本类型也称为值类型，分别是字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double
引用类型则包括类（String）、接口、数组、枚举等。

Java内存模型
Java将内存空间分为堆和栈（当然不只这两部分）。基本类型直接在栈中存储数值，而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中
的引用指向堆中存放的数据。
可以学习这位老哥的博客https://www.cnblogs.com/xinruyi/p/11595824.html，里面有图形说明思路更清晰。

下面开始看代码实现

总结：
    浅拷贝对于引用类型还是存得同一个引用类型的地址值，所有对克隆出来的对象的引用类型状态(成员变量值)进行修改时，那么所有对象的引用类型状态都变了。
多个对象都共用了一个引用对象。
    深拷贝是在拷贝的时候对应引用类型变量是重新在堆里面生成了一个对象并让成员变量指向了这个堆中的地址，所以原生对象和克隆出来的对象指向的不是同一个堆内存地址，改变对应的引用变量状态时是互不影响的。
